# Reids 持久化
## RDB 持久化技术
```
    Redis 默认的持久化方式，是一个压缩的二进制文件，通过该 rdb文件恢复数据库状态
```
### RDB 文件的创建
```
   RDB 文件的创建可以通过 SAVE 命令和 BGSAVE 命令指定。区别是，SAVE 命令会阻塞服务器进程直到
文件生成完毕，期间不处理任何命令请求；BGSAVE 则是通过 fork 一个子进程去创建 RDB 文件，服务器
进程（父进程）可继续处理命令请求。
   当文件生成后，新的 RDB 文件就会原子的替换旧的 RDB 文件。
   在执行 BGSAVE 期间，SAVE、BGSAVE 或 BGREWRITEAOF 命令请求均不会执行。其中，SAVE 和 BGSAVE
会直接被拒绝（避免父子进程同时执行两个 rdbSave 调用，防止产生竞争）；BGREWRITEAOF 则会被延迟到
BGSAVE 命令执行完成后再执行。
    如果是 BGREWRITEAOF 在执行，客户端发送 BGSAVE 命令则会被拒绝，原因是两者都是由子进程执行的，
操作上没有冲突，鉴于性能上的考虑，两者不能同时执行（同时执行会产生大量的 IO 操作）
```
### RDB 文件的载入
```
    如果没有开启 AOF 持久化功能，在启动时检测到 rdb 文件，就会自动载入。否则，服务器会优先使用
AOF 文件来还原数据库状态，因为 AOF 文件的更新频率高于 RDB文件。
    RDB 文件的载入是在服务器启动时自动执行的，所有没有用于载入的命令，载入期间进程是阻塞的。
```
### 自动保存间隔
```
    RDB 一般使用 BGSAVE 来执行持久化，因其不会阻塞服务器进程。在 Redis 的配置文件中，有关于
服务器每隔多久来执行 BGSAVE 命令。
    默认配置是， 1次请求，900s 保存一次；10次请求，300s保存一次，10000次请求，60s保存一次择一而执行
```
## AOF 持久化技术
```
    RDB 持久化是通过保存数据库状态来持久化的，而 AOF 与之不同，它是通过保存对数据库的写命令来记录状态的。
写命令如 set key 123, 请求后会被保存到 aof 命令中
```
### AOF 持久化实现
```
    AOF 持久化的实现分为3个步骤：命令追加、文件写入、文件同步。
    1. 命令追加：就是将写命令追加到 AOF 缓冲区的末尾。
    2. 文件写入：就是将缓冲区的内容写到 AOF 文件中去。
    3. 文件同步：就是将 AOF 文件保存到磁盘。
    Redis 服务器进程就是一个事件循环，这个循环中的文件事件（socket的可写可读事件）负责接收客户端的命令
请求，以及向客户端发送命令结果。处理事件是，如果发生写操作，这些内容就会被追加到 AOF 缓冲区末尾，所以每
次结束一个事件循环之前，都会调用 flushAppendOnlyFile 方法。
    flushAppendOnlyFile 方法执行两个工作：
    1. write： 根据条件，将缓冲区的内容写入到 AOF 文件
    2. save：  根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中
    这两个步骤都需要一定的条件来执行，而这些条件由 Redis 配置文件中的 appendfsync 选项来决定：
    1. appendfsync always: 每执行一个命令保存一次【write 和 save 都会被执行，save和write均阻塞】
    2. appendfsync everysec: 每一秒钟保存一次（默认，推荐值）【save原则上每隔一秒执行一次，仅write阻塞】
    3. appendfsync no: 不保存。【每执行完一个命令，write会执行save都会被忽略-均阻塞-，除非出现以下情况：
        a. Redis 被关闭
        b. AOF 功能被关闭
        c. 系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行，依赖OS的写入，一般30s一周期）
    】
    原则上，always 最多丢失一个命令， everysec 丢失不超过2s的数据，no则是上一次save后的所有数据均会丢失。
    * 随时间的推移，AOF文件内容越来越多，导致文件过大恢复过久，此时可用AOF文件重写功能
```
### AOF 重写
```
    该功能通过创建一个新的 AOF文件来代替旧文件，并且两个文件所保存的数据库状态一致但新文件不包含任何冗余的
命令，故此该文件会比旧文件小很多。
    重写是通过读取数据库服务器当前的数据库状态来实现的，并未对旧文件进行任何读取和修改。
    因涉及到大量的 IO 操作，所以 Redis 是用子进程来实现这个功能的，否则将会阻塞主进程，该子进程拥有父
进程的数据副本，可以在避免使用锁的情况下，保证数据的安全性。
    为了解决重写期间会有写请求导致 AOF 文件与当前数据库状态不一致，Redis 设置了一个 AOF 重写缓冲区，在子
进程执行 AOF 重写期间，主进程执行以下三个事件：
    1. 执行客户端的请求命令
    2. 将执行后的写命令追加到 AOF 缓冲区
    3. 将执行后的写命令追加到 AOF 重写缓冲区
    子进程重写结束后，会像主进程发送一个信号，主进程收到信号好会调用信号处理函数执行以下步骤：
    1. 将 AOF 重写缓冲区的内容写入新的 AOF 问价中，此时文件和数据库的状态就一致了
    2. 对新文件进行改名，原子的覆盖现有的 AOF 文件，完成对旧文件的替换。
    当函数执行完毕后，主进程旧继续处理客户端的请求，因此，在整个 AOF 重写过程中，只有执行信号处理函数时才会
阻塞主进程，其他时候都不会阻塞。
```
## 选择持久化方案的官方建议
```
    如果想要提供很高的数据保障性，建议同时使用两种持久化方式，如果可以接收灾难带来的几分钟的数据丢失，可以仅
仅使用 RDB 方式。RDB 可以是不是的给数据做个完整的快照，并且提供更快的重启，所以最好使用 RDB.
    RDB 启动时间较短的原因：
    1. RDB 文件中，每一条数据只有一条记录，不会像 AOF 日志那样可能有多次操作。
    2. RDB 文件的存储格式和 Redis 数据在内存中的编码格式一致，不需要进行数据编码工作，cpu消耗小于 AOF 
    * RDB 快照持久化，在进行快照的时候（save),fork 出来进行 dump 操作的子进程会占用与父进程一样的内存
是真正的 copy-on-write ,对性能的影响和内存的消耗都比较大。目前通常的设计思路是利用复制（Replication)
机制来弥补 aof、snapshot 性能上的不足，达到了数据可持久化。即 Master 上的 Snapshot 和 AOF 都不做，来保证 
Master 的读写性能，而 Slave 上则同时开启 Snapshot 和 AOF 来进行持久化，保证数据的安全性。
```
