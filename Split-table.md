# 分表分库
## 分表
        数据量很大（建议一张表200w数据左右），导致表很大，导致查询很慢的时候，需要进行分表操作，
        一般使用hash进行表数据分割，但是，分表不能解决并发问题，如果想要高并发，需要进行分库。
## 分库
        访问量过高（一般单库建议并发量在1000tps），如果访问量过高，就需要进行分库，将表分割到不同的数据库实例中，分担并发量。
## shardingSquare
        360开源，client处理分表分库问题，不需要部署中间件，中小型公司使用，不需要额外的维护，
        但是升级时需要全量回归测试和升级，和业务耦合读较高
## mycat
        大型公司使用，需要专门人员维护，升级只和中间件有关系，和业务分离。
## 水平分割
        利用分表分库技术，提高并发和查询效率
## 垂直分割
        对表字段进行拆分，将热点数据和几乎不用的数据字段分割到不同的表中。
## 读写分离
        主库写入，变更时写入binlog日志，从库连到主库将主库的binlog拷贝到本地，写入一个relay中继日志中，
        接着一个sql线程从中继日志中读取binlog，然后执行binglog中的日志，保证自己和主库一致。但是如果并发较高，
        会出现分库读取有延时，导致数据同步问题。为了防止，可以使用半同步复制和并行复制。
## 半同步复制
        semi-sync复制，指的是主库写入binlog后，就强制将此数据同步到从库，从库写入本地的relay log中后，接着会返回一个ack给主库，
        主库接收到至少一个从库的ack后才会任务写操作完成。
## 并行复制
        指从库开启多个线程，并行读取relay log，然后并行重放不同库的日志，是库级别的并行。
## snowflake算法
        twitter开源的分布式id生成算法，scala语言实现，用64位的long型做id，1bit高位，永远是0（正数），
        41位表示时间戳，单位是毫秒，10bit是工作机器id，其中5bit是机器id，5bit是机房id，12bit是同一个毫秒内产生的不同的id，
        最大值是4096；因为uuid不是有序的且太长了，性能查，b+数索引在写的时候有过多的随机写操作，同时不能产生顺序的append操作，
        且不需要进行insert操作，竟会读取整个B+树节点到内存，性能会下降
